#!/usr/bin/env node
/**
 * Generates TypeScript catalog files from pnpm-workspace.yaml.
 *
 * Reads the `silk` and `silkPeers` catalogs from the local workspace
 * configuration and generates the corresponding TypeScript source files.
 *
 * Usage: pnpm run generate:catalogs
 */

import { readFileSync, writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { parse as parseYaml } from "yaml";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = join(__dirname, "..");

interface WorkspaceConfig {
	catalogs?: {
		silk?: Record<string, string>;
		silkPeers?: Record<string, string>;
	};
}

/**
 * Read and parse pnpm-workspace.yaml
 */
function readWorkspaceConfig(): WorkspaceConfig {
	const workspacePath = join(ROOT_DIR, "pnpm-workspace.yaml");
	const content = readFileSync(workspacePath, "utf-8");
	return parseYaml(content) as WorkspaceConfig;
}

/**
 * Format a catalog object as TypeScript code.
 */
function formatCatalog(catalog: Record<string, string>, indent = "\t\t"): string {
	const entries = Object.entries(catalog)
		.sort(([a], [b]) => a.localeCompare(b))
		.map(([pkg, version]) => {
			// Quote package names that contain special characters
			const key = pkg.includes("/") || pkg.includes("-") ? `"${pkg}"` : pkg;
			return `${indent}${key}: "${version}",`;
		});
	return entries.join("\n");
}

/**
 * Generate the TypeScript catalog file content.
 */
function generateCatalogFile(silk: Record<string, string>, silkPeers: Record<string, string>): string {
	const timestamp = new Date().toISOString();

	return `/**
 * Auto-generated Silk catalog definitions.
 *
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Instead, update pnpm-workspace.yaml and run: pnpm run generate:catalogs
 *
 * Generated: ${timestamp}
 *
 * @packageDocumentation
 */

import type { SilkCatalogs } from "./types.js";

/**
 * The complete Silk catalogs generated from pnpm-workspace.yaml.
 *
 * - \`silk\`: Current/latest versions for direct dependencies
 * - \`silkPeers\`: Permissive ranges for peerDependencies
 */
export const silkCatalogs: SilkCatalogs = {
	silk: {
${formatCatalog(silk)}
	},
	silkPeers: {
${formatCatalog(silkPeers)}
	},
};
`;
}

/**
 * Main entry point.
 */
function main(): void {
	console.log("Reading pnpm-workspace.yaml...");

	const config = readWorkspaceConfig();

	if (!config.catalogs?.silk) {
		console.error("Error: No 'catalogs.silk' found in pnpm-workspace.yaml");
		process.exit(1);
	}

	if (!config.catalogs?.silkPeers) {
		console.error("Error: No 'catalogs.silkPeers' found in pnpm-workspace.yaml");
		process.exit(1);
	}

	const silk = config.catalogs.silk;
	const silkPeers = config.catalogs.silkPeers;

	console.log(`Found ${Object.keys(silk).length} entries in silk catalog`);
	console.log(`Found ${Object.keys(silkPeers).length} entries in silkPeers catalog`);

	const content = generateCatalogFile(silk, silkPeers);
	const outputPath = join(ROOT_DIR, "src/catalogs/generated.ts");

	writeFileSync(outputPath, content, "utf-8");
	console.log(`Generated: ${outputPath}`);

	// Validate that silkPeers has entries for all silk packages
	const silkOnly = Object.keys(silk).filter((pkg) => !(pkg in silkPeers));
	if (silkOnly.length > 0) {
		console.warn("\nWarning: The following packages are in silk but not silkPeers:");
		for (const pkg of silkOnly) {
			console.warn(`  - ${pkg}`);
		}
	}

	console.log("\nDone! Remember to run 'pnpm run lint:fix' to format the generated file.");
}

main();
